
# ----------

from fastapi import FastAPI, HTTPException
from starlette.responses import Response, HTMLResponse
import uvicorn
import multiprocessing

from starlette.staticfiles import StaticFiles

from oneringcore import OneRingCore

import asyncio

app = FastAPI()

version = "2.0"

core:OneRingCore = None

app.mount("/webapi_client", StaticFiles(directory="webapi_client", html = True), name="webapi_client")

@app.get("/", response_class=HTMLResponse)
async def read_items():
    html_content = """
    <html>
        <head>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>OneRingTranslator</title>
            <link rel="stylesheet" href="/webapi_client/chota.min.css">
        </head>
        <body>
            <div id="top" class="container" role="document">
                <h1>Welcome to OneRingTranslator!</h1>
                
                <a href="/webapi_client" class="button">Simple interface</a><br />
                <br />
                <a href="/docs" class="button">API and docs</a>
            </div>
        </body>
    </html>
    """
    return HTMLResponse(content=html_content, status_code=200)

@app.on_event("startup")
async def startup_event():
    global core
    core = OneRingCore()
    core.init_with_plugins()
    pass

@app.get(
    "/translate",

    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    # responses = {
    #     200: {
    #         "content": {"text": {}}
    #     }
    # },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    # response_class=Response
)
async def translate(text:str, from_lang:str = "", to_lang:str = "", translator_plugin:str = "", add_params:str = "", api_key:str = ""):
    """
       Return translation

       :param str text: text to translate

       :param str from_lang: from language (2 symbols, like "en"). May be "user" (will be replaced to "user_lang" from options)

       :param str to_lang: to language (2 symbols, like "en"). May be "user" (will be replaced to "user_lang" from options)

       :param str translator_plugin: to use. If blank, default will be used. If not inited plugin will call, core try to init plugin

       :param str add_params: additional params for translation (depends on plugin)

       :param str api_key: api key for access (if service setup in security mode with api keys)

       :return: dict (result: text)
       """


    #return Response(content=data, media_type="text/wav")
    if len(core.api_keys_allowed) > 0: # there are some api keys
        if api_key == "":
            return {"error": "API key required"}
        if not (api_key in core.api_keys_allowed):
            return {"error": "No valid API key provided"}




    if core.is_multithread:
        #print("Multithread")
        #res = await asyncio.to_thread(core.translators[translator_plugin][1], core, text, from_lang, to_lang, add_params)

        # init before other threads will run
        if translator_plugin != "":
            core.init_translator_engine(translator_plugin)

            if translator_plugin not in core.inited_translator_engines:
                return {"error": "Translator plugin not inited"}

        res = await asyncio.to_thread(core.translate, text, from_lang, to_lang, translator_plugin,
                                      add_params)
    else:
        res = core.translate(text,from_lang,to_lang,translator_plugin,add_params)



    # import time
    # time.sleep(1)

    return res #{"result": res}

@app.get(
    "/translator_plugin_info",
)
async def translator_plugin_info(api_key:str = ""):
    """
       Return list of available translator plugins

       :param int api_key: api key for access (if service setup in security mode with api keys)

       :return: dict with info
       """
    if len(core.api_keys_allowed) > 0: # there are some api keys
        if api_key == "":
            return {"error": "API key required"}
        if not (api_key in core.api_keys_allowed):
            return {"error": "No valid API key provided"}

    full_list = list(core.translators.keys())
    inited_list = core.inited_translator_engines
    return {"result": {
        "default": core.default_translator,
        "all_translator": full_list,
        "inited_translator": inited_list,
        "user_lang": core.user_lang
    }}

@app.get(
    "/whois",
)
async def whois():
    """
       Return whois service info

       :return: dict with info
       """
    from oneringcore import version
    return {"result": {
        "service": "OneRingTranslator",
        "version": version,
    }}

if __name__ == "__main__":
    #multiprocessing.freeze_support()
    print("Running OneRingTranslator server v{0}...".format(version))
    uvicorn.run("run_webapi:app", host="127.0.0.1", port=4990, log_level="info")